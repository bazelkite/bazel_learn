## Bazel-Powered Pipeline (WITH Bazel)
## This demonstrates Bazel's intelligence with dynamic pipeline generation

steps:
  - label: ":bazel: Setup & Verify"
    command: |
      echo "--- :bazel: Bazel version"
      bazel version
      
      echo "--- :package: List all Bazel targets"
      bazel query //...
      
      echo "--- :mag: Query all test targets"
      bazel query "kind('.*_test', //...)"

  - wait

  - label: ":pipeline: Generate Dynamic Pipeline"
    command: |
      #!/bin/bash
      set -euo pipefail
      
      echo "--- :thinking_face: Analyzing codebase with Bazel"
      
      # Find all test targets using Bazel query
      echo "Finding all test targets..."
      ALL_TESTS=$$(bazel query "kind('.*_test', //...)" 2>/dev/null || echo "")
      
      # Find all binary targets
      echo "Finding all binary targets..."
      ALL_BINARIES=$$(bazel query "kind('.*_binary', //...)" 2>/dev/null || echo "")
      
      echo "--- :pipeline: Generating dynamic pipeline"
      
      # Start building the pipeline
      cat > dynamic-pipeline.yml <<'PIPELINE_START'
      steps:
        - label: ":test_tube: Run All Tests (Parallel)"
          command: |
            echo "Running all tests with Bazel..."
            bazel test //... --test_output=errors
          
        - wait
        
      PIPELINE_START
      
      # Add individual test steps for visibility
      echo "  - label: ':bar_chart: Test Results Breakdown'" >> dynamic-pipeline.yml
      echo "    command: |" >> dynamic-pipeline.yml
      echo "      echo '--- :test_tube: Individual Test Results'" >> dynamic-pipeline.yml
      
      if [ -n "$$ALL_TESTS" ]; then
        for test in $$ALL_TESTS; do
          echo "      echo 'Testing: $$test'" >> dynamic-pipeline.yml
          echo "      bazel test $$test --test_output=errors || true" >> dynamic-pipeline.yml
        done
      fi
      
      # Add build steps
      cat >> dynamic-pipeline.yml <<'PIPELINE_BUILD'
      
        - wait
        
        - label: ":package: Build All Binaries"
          command: |
            echo "Building all binaries with Bazel..."
            bazel build //services/...
            
            echo "--- :file_folder: Build outputs"
            find bazel-bin/services -name "hello" -o -name "goodbye" | while read binary; do
              echo "Built: $binary"
              ls -lh "$binary"
            done
      
        - wait
        
        - label: ":rocket: Run Services"
          command: |
            echo "--- :wave: Running hello service"
            bazel run //services/hello:hello
            
            echo ""
            echo "--- :wave: Running goodbye service"
            bazel run //services/goodbye:goodbye
      
        - wait
        
        - label: ":mag: Dependency Analysis"
          command: |
            echo "--- :chart_with_upwards_trend: Analyzing dependencies"
            
            echo "Dependencies of hello service:"
            bazel query "deps(//services/hello:hello)" --output package
            
            echo ""
            echo "Dependencies of goodbye service:"
            bazel query "deps(//services/goodbye:goodbye)" --output package
            
            echo ""
            echo "What depends on lib/utils?"
            bazel query "rdeps(//..., //lib/utils:utils)" 2>/dev/null || echo "None (or service doesn't use it)"
      
        - wait
        
        - label: ":memo: Bazel Build Summary"
          command: |
            cat <<EOF | buildkite-agent annotate --style success --context bazel-summary
            ## Bazel Build Summary
            
            ### What Happened
            - âœ… **Intelligent caching**: Only rebuilt what changed
            - âœ… **Parallel execution**: Tests ran concurrently
            - âœ… **Dependency tracking**: Bazel knows what depends on what
            - âœ… **Hermetic builds**: Same results everywhere
            - âœ… **Dynamic generation**: Pipeline adapted to codebase
            
            ### Advantages of Bazel
            - âœ… **Incremental builds**: Only rebuilds affected targets
            - âœ… **Remote caching**: Can share build artifacts across team
            - âœ… **Dependency analysis**: \`bazel query\` shows impact of changes
            - âœ… **Multi-language**: One build system for all languages
            - âœ… **Scalability**: Handles massive monorepos
            
            ### Build Intelligence
            \`\`\`
            # Only test what's affected by changes:
            bazel query "rdeps(//..., //lib/utils:utils)"
            
            # Find all tests:
            bazel query "kind('.*_test', //...)"
            
            # Visualize dependencies:
            bazel query "deps(//services/hello:hello)" --output graph
            \`\`\`
            
            ### Performance
            - **First build**: Downloads toolchains, builds everything
            - **Subsequent builds**: Only rebuilds changed targets (seconds!)
            - **With remote cache**: Even faster across team
            
            ---
            ðŸ’¡ **This pipeline was generated dynamically using \`bazel query\`**
            EOF
      PIPELINE_BUILD
      
      echo "--- :rocket: Uploading dynamic pipeline"
      cat dynamic-pipeline.yml
      buildkite-agent pipeline upload dynamic-pipeline.yml

  - wait

  - label: ":chart_with_upwards_trend: Compare: Bazel vs Traditional"
    command: |
      cat <<EOF | buildkite-agent annotate --style info --context comparison
      ## Bazel vs Traditional Build: Side-by-Side
      
      | Aspect | Traditional (pipeline.yaml) | Bazel (pipeline.bazel.yaml) |
      |--------|---------------------------|---------------------------|
      | **Caching** | âŒ None | âœ… Intelligent caching |
      | **Incremental** | âŒ Rebuilds everything | âœ… Only changed targets |
      | **Dependency Awareness** | âŒ No | âœ… Full dependency graph |
      | **Maintenance** | âŒ Manual updates | âœ… Self-adapting |
      | **Multi-language** | âŒ Separate tools | âœ… Unified system |
      | **Reproducibility** | âš ï¸ Environment-dependent | âœ… Hermetic builds |
      | **Scalability** | âŒ Poor | âœ… Excellent |
      | **Query Capabilities** | âŒ None | âœ… \`bazel query\` |
      
      ### Time Savings Example
      
      **Scenario**: Change one file in \`lib/utils\`
      
      **Traditional Build**:
      - Tests all 3 packages (even unaffected ones)
      - Builds all 2 services (even unaffected ones)
      - Time: ~2-3 minutes (every time)
      
      **Bazel Build**:
      - \`bazel query "rdeps(//..., //lib/utils:utils)"\` finds affected targets
      - Only tests/builds affected targets
      - Uses cached results for everything else
      - Time: ~10-30 seconds (with cache)
      
      ### Dynamic Pipeline Generation
      
      The Bazel pipeline uses \`bazel query\` to discover targets automatically:
      
      \`\`\`bash
      # Find all tests dynamically
      ALL_TESTS=\$$(bazel query "kind('.*_test', //...)")
      
      # Generate pipeline steps for each test
      for test in \$$ALL_TESTS; do
        echo "  - command: bazel test \$$test" >> pipeline.yml
      done
      \`\`\`
      
      **Result**: Pipeline adapts as you add/remove services. No manual updates needed!
      
      ---
      
      ### Try It Yourself
      
      \`\`\`bash
      # See all targets
      bazel query //...
      
      # Find what depends on utils library
      bazel query "rdeps(//..., //lib/utils:utils)"
      
      # Show dependency graph
      bazel query "deps(//services/hello:hello)" --output graph
      
      # Only test affected targets (simulating a change)
      bazel test \$$(bazel query "rdeps(//..., //lib/utils:utils)")
      \`\`\`
      EOF

cache:
  paths:
    - "bazel-bin"
    - "bazel-out"
    - "bazel-testlogs"
  size: "50g"

steps:
  - label: ":bazel: Discover & Test"
    command: |
      echo "--- Discovering all test targets"
      bazel query "kind('.*_test', //...)"

      echo "--- Running all tests"
      bazel test //... --test_output=errors

  - wait: ~

  - label: ":bazel: Build & Run Services"
    command: |
      echo "--- Building all services"
      bazel build //services/...

      echo "--- Running hello service"
      bazel run //services/hello:hello

      echo "--- Running goodbye service"
      bazel run //services/goodbye:goodbye

  - wait: ~

  - label: ":mag: Dependency Intelligence"
    command: |
      echo "--- What depends on lib/utils?"
      bazel query "rdeps(//..., //lib/utils:utils)"

      echo ""
      echo "--- All test targets"
      bazel query "kind('.*_test', //...)"

  - wait: ~

  - label: ":memo: Summary"
    command: |
      cat <<EOF | buildkite-agent annotate --style success
      ## Bazel Build: What Just Happened?

      ✅ **Intelligent caching** - only rebuilt what changed
      ✅ **Parallel execution** - tests ran concurrently
      ✅ **Dependency tracking** - knows exactly what's affected by changes
      ✅ **Dynamic discovery** - automatically finds all targets (no manual updates!)

      ### The Magic: \`bazel query\`

      \`\`\`bash
      # Find what depends on a library
      bazel query "rdeps(//..., //lib/utils:utils)"

      # Test only affected targets
      bazel test \$$(bazel query "kind('.*_test', rdeps(//..., //lib/utils:utils))")
      \`\`\`

      This is how you build intelligent CI pipelines!
      EOF
